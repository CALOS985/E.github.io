<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="content-type"/>
  <title>
   8.公用状态修改：移动、跳跃、受身及防御
  </title>
  <style type="text/css">
   <!--
body,td,th {
	font-family: Verdana, Arial, Helvetica, sans-serif;
}
.STYLE1 {
	color: #FF0000;
	font-weight: bold;
	font-size: xx-large;
}
.STYLE2 {
	color: #FF00FF;
	font-weight: bold;
}
.STYLE3 {
	color: #0000FF
}
-->
  </style>
 </head>
 <body>
  <p class="STYLE1">
   8.公用状态修改：移动、跳跃、受身及防御
  </p>
  <span class="STYLE3">
   本页内容由口水轩撰写. 由【softmgr】整理编辑.
  </span>
  <br/>
  <p>
   终于真正的开始写AI了。从第8章开始到第13章，都是关于AI的编写。
   <br/>
   从这章开始我们正式接触人物里面的代码。代码比较长可能比较难理解，建议一段一段的读，不要被长度给吓到，多壮观的建筑都
   <br/>
   是一砖一瓦搭成的，无论多长的代码也是如此，把每段代码逐个击破合起来就是你想要的答案。
   <br/>
   首先我们先从各个人物几乎都有的状态开始入手，也就是公用状态。
   <br/>
  </p>
  <p>
   ==================================================
   <br/>
   <span class="STYLE2">
    8.1公用状态与Stcommon简介
   </span>
   <br/>
   ==================================================
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   公用状态是一些各个人物几乎都有的状态，而这些状态的状态号基本上也是固定的。
   <br/>
   例如站姿0，蹲姿10~12，行走20，起跳40，跑/前冲100，后撤105，防御120～155，倒地5110，起身5120等等。
   <br/>
   <br/>
   Stcommon是一个存放公用状态的特殊st文件。
   <br/>
   如果其他st文件没有重复定义Stcommon里面的状态，人物将会使用Stcommon里面定义的状态。
   <br/>
   Mugen在data文件夹里面附有默认的common1.cns，如果人物没有自带Stcommon文件，那么人物会调用这个common1.cns。
   <br/>
   因此，如果人物自带Stcommon文件，那么我们就直接对那个文件进行修改；如果人物没有自带Stcommon文件的话，就要在人物文件
   <br/>
   夹内自己新建/复制一个Stcommon文件，并把Def文件内的Stcommon路径改成你文件的路径。
   <br/>
   <br/>
   打开common1.cns后我们可以发现，其实Stcommon和一般的st文件没有太多不同。
   <br/>
   里面很多Sctrl其实是不需要管的，如第5章所说，我们只需要看会被command影响的某些Sctrl。
   <br/>
   一般来说这些涉及的内容包括：移动（行走、跑、前冲、后撤、跳跃）、受身及防御。
   <br/>
  </p>
  <p>
   ==================================================
   <br/>
   <span class="STYLE2">
    8.2行走
   </span>
   <br/>
   ==================================================
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   行走是格斗游戏最为常见的移动方式之一。
   <br/>
   虽然移动速度比较慢，但是全程都是属于可控状态，可以随时应对各种情况，是最安全的移动方式。
   <br/>
   <br/>
   <br/>
   默认的common1.cns中代码如下：
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; Walk
   <br/>
   [Statedef 20]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   sprpriority = 0
   <br/>
   <br/>
   [State 20, 1]
   <br/>
   type = VelSet
   <br/>
   trigger1 = command = "holdfwd"
   <br/>
   x = const(velocity.walk.fwd.x)
   <br/>
   <br/>
   [State 20, 2]
   <br/>
   type = VelSet
   <br/>
   trigger1 = command = "holdback"
   <br/>
   x = const(velocity.walk.back.x)
   <br/>
   <br/>
   [State 20, 3]
   <br/>
   type = ChangeAnim
   <br/>
   triggerall = vel x &gt; 0
   <br/>
   trigger1 = Anim != 20 &amp;&amp; Anim != 5
   <br/>
   trigger2 = Anim = 5 &amp;&amp; AnimTime = 0
   <br/>
   value = 20
   <br/>
   <br/>
   [State 20, 4]
   <br/>
   type = ChangeAnim
   <br/>
   triggerall = vel x &lt; 0
   <br/>
   trigger1 = Anim != 21 &amp;&amp; Anim != 5
   <br/>
   trigger2 = Anim = 5 &amp;&amp; AnimTime = 0
   <br/>
   value = 21
   <br/>
   <br/>
   <br/>
   如代码所示，默认的行走分为向前走和向后走，这两个方向的行走用的是同一个状态号20。
   <br/>
   这个状态会根据手操按键的不同（也就是前和后）而切换为对应的动画（动画20和21）和速度。
   <br/>
   然而这样一个状态包含两个不同属性的动作的情况是相当不利于AI编写的。
   <br/>
   因为这样不但要在Statedef -1/-3里面加入对应的trigger使其动起来，还要在stcommon文件里面区分前后两种情况，
   <br/>
   分开两个地方去管理一类型动作。这么做相当麻烦还容易出错，所以我们要对其进行一定的调整。
   <br/>
   比较常用的方法是新建一个（或者一些）状态来区分不同的动作，以后写状态切换的时候就会简单不少。
   <br/>
   <br/>
   <br/>
   实例如下：
   <br/>
   <br/>
   ;下面两段放到[Statedef 20]附近
   <br/>
   ;--------------------------------------------------
   <br/>
   ; Walk B 向后走
   <br/>
   [Statedef 19]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   sprpriority = 0
   <br/>
   <br/>
   [State 20, 2]
   <br/>
   type = VelSet
   <br/>
   trigger1 = 1
   <br/>
   x = const(velocity.walk.back.x)
   <br/>
   <br/>
   [State 20, 4]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = Anim != 21 &amp;&amp; Anim != 5
   <br/>
   trigger2 = Anim = 5 &amp;&amp; AnimTime = 0
   <br/>
   value = 21
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; Walk F 向前走
   <br/>
   [Statedef 21]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   sprpriority = 0
   <br/>
   <br/>
   [State 20, 1]
   <br/>
   type = VelSet
   <br/>
   trigger1 = 1
   <br/>
   x = const(velocity.walk.fwd.x)
   <br/>
   <br/>
   [State 20, 3]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = Anim != 20 &amp;&amp; Anim != 5
   <br/>
   trigger2 = Anim = 5 &amp;&amp; AnimTime = 0
   <br/>
   value = 20
   <br/>
   <br/>
   <br/>
   之后写上让人物行走的Changestate就可以了：
   <br/>
   <br/>
   ;下面一段放到[Statedef -1]或[Statedef -3]下面
   <br/>
   ;--------------------------------------------------
   <br/>
   [State -1, 向前走]
   <br/>
   type = ChangeState
   <br/>
   value = 21
   <br/>
   Triggerall = Var(59) &gt; 0;AI开启时
   <br/>
   Triggerall = Roundstate = 2;在格斗阶段
   <br/>
   Triggerall = Statetype != A;不在空中
   <br/>
   Triggerall = Frontedgebodydist &gt;= 10;不在画面边缘
   <br/>
   Triggerall = Stateno != 20 &amp;&amp; Stateno != 100;不是步行状态和跑步状态
   <br/>
   Triggerall = ctrl;可控时
   <br/>
   Trigger1 = P2bodydist X &gt; 135 &amp;&amp; Random &lt; P2bodydist X * 2 - 250;Trigger1~4根据距离不同分段改变概率
   <br/>
   Trigger2 = P2bodydist X &gt; 100 &amp;&amp; Random &lt; P2bodydist X
   <br/>
   Trigger3 = P2bodydist X &gt; 50 &amp;&amp; Random &lt; 100
   <br/>
   Trigger4 = P2bodydist X &gt; 0 &amp;&amp; Random &lt; 25
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   [State -1, 向后走]
   <br/>
   type = ChangeState
   <br/>
   value = 19
   <br/>
   Triggerall = Var(59) &gt; 0
   <br/>
   Triggerall = Roundstate = 2
   <br/>
   Triggerall = Statetype != A
   <br/>
   Triggerall = Backedgebodydist &gt;= 10
   <br/>
   Triggerall = !inguarddist;非防御距离，因为防御距离内按后会变成防御而不是向后走
   <br/>
   Triggerall = ctrl
   <br/>
   Trigger1 = P2bodydist X &lt; 75 &amp;&amp; Random &gt; 950 + P2bodydist X / 2;近距离低几率触发
   <br/>
   <br/>
   之后人物就会根据不同的距离以不同的概率随机前后行走了。
   <br/>
  </p>
  <p>
   ==================================================
   <br/>
   <span class="STYLE2">
    8.3跑/前冲/后撤
   </span>
   <br/>
   ==================================================
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   跑/前冲也是格斗游戏非常常见的移动方式。
   <br/>
   虽然移动速度比较快，但是跟行走对比起来相对不灵活，有一定的风险。
   <br/>
   然而较快的速度令它在抢硬直、连段目押等需要快速移动的情况大展身手。
   <br/>
   <br/>
   默认的common1.cns中代码如下：
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; Run forward
   <br/>
   [Statedef 100]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   anim = 100
   <br/>
   sprpriority = 1
   <br/>
   <br/>
   [State 100, 1]
   <br/>
   type = VelSet
   <br/>
   trigger1 = 1
   <br/>
   x = const(velocity.run.fwd.x)
   <br/>
   <br/>
   [State 100, 2] ;Prevent run from canceling into walk
   <br/>
   type = AssertSpecial
   <br/>
   trigger1 = 1
   <br/>
   flag = NoWalk
   <br/>
   <br/>
   [State 100, 3] ;Prevent from turning
   <br/>
   type = AssertSpecial
   <br/>
   trigger1 = 1
   <br/>
   flag = NoAutoTurn
   <br/>
   <br/>
   [State 100, 4]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = command != "holdfwd"
   <br/>
   value = 0
   <br/>
   <br/>
   如代码所示，默认的是跑，是可控的匀速前进，并且可以随时停下。
   <br/>
   然而，很多格斗游戏里面的跑并不是这么简单的，通常是由起步、匀速运动、停止之类的部分组成。
   <br/>
   因为起步和停止都是有一定硬直的动作，如果在较短的距离开始跑，对方一旦使用攻击，你将没法停下来进行防御。
   <br/>
   和行走对比起来，这类型的跑使用起来需要考虑更多问题。
   <br/>
   <br/>
   <br/>
   虽然跑并没有行走那样有两个方向的烦恼，但是跑的启动和停止是分开控制的，并不是像行走那样不需要变为State 0的Sctrl。
   <br/>
   所以除了启动我们还要改写Statedef 100下的停止条件：
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; Run forward
   <br/>
   [Statedef 100]
   <br/>
   <br/>
   ...
   <br/>
   <br/>
   [State 100, 4]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = Var(59) = 0;AI未开启时
   <br/>
   trigger1 = command != "holdfwd";和原来一样接受手操指令
   <br/>
   trigger2 = Var(59) &gt; 0
   <br/>
   trigger2 = EnemyNear,movetype != H || (EnemyNear,movetype = H &amp;&amp; p2dist x &lt; 0);对方不在受击状态或者对方在受击状态但跑过头了
   <br/>
   trigger2 = p2bodydist x &lt;= (30+random/40) || Frontedgebodydist &lt;= 10;比较近的距离或者画面边缘
   <br/>
   trigger3 = Var(59) &gt; 0
   <br/>
   trigger3 = Roundstate != 2;防止非战斗阶段时一直跑根本停不下来
   <br/>
   value = 0
   <br/>
   <br/>
   <br/>
   之后写上让人物跑的Changestate就可以了：
   <br/>
   <br/>
   ;下面一段放到[Statedef -1]或[Statedef -3]下面
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   [State -1, 前跑]
   <br/>
   type = ChangeState
   <br/>
   value = 100
   <br/>
   Triggerall = Var(59) &gt; 0
   <br/>
   Triggerall = Roundstate = 2
   <br/>
   Triggerall = Statetype != A
   <br/>
   Triggerall = Frontedgebodydist &gt;= 20;避免在画面边缘开始跑
   <br/>
   Triggerall = ctrl
   <br/>
   Trigger1 = P2bodydist X &gt; 200 &amp;&amp; Random &lt; P2bodydist X*5 - 720;Trigger1~4根据距离不同分段改变概率
   <br/>
   Trigger2 = P2bodydist X &gt; 135 &amp;&amp; Random &lt; P2bodydist X*2 - 120
   <br/>
   Trigger3 = P2bodydist X &gt; 90 &amp;&amp; Random &lt; P2bodydist X*1.75 - 90
   <br/>
   Trigger4 = (P2bodydist X = [45,90]) &amp;&amp; Random &lt; P2bodydist X *1.2 - 45
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   虽然Mugen内默认的状态100是跑，但一些游戏当中双击前方向键（66）并不一定是跑，还有可能是前冲（冲刺/Dash）。
   <br/>
   前冲很有可能是长时间硬直的向前移动，若乱使用可以说破绽百出，使用时比起跑要更小心，否则就是给对方送硬直。
   <br/>
   <br/>
   后撤默认使用的是状态105，是双击后方向键（44）所发出来的。
   <br/>
   在Mugen中，后撤默认为空中状态，也就是启动的瞬间就在空中，所以可以利用这个特性躲避投技。
   <br/>
   而在不少格斗游戏作品当中，后撤会有短暂无敌的性能，我们也可以利用这性能对对方攻击进行闪避。
   <br/>
   <br/>
   <br/>
   因为默认并没有前冲，所以在此只给出后撤的例子：
   <br/>
   <br/>
   ;下面一段放到[Statedef -1]或[Statedef -3]下面
   <br/>
   ;--------------------------------------------------
   <br/>
   [State -1, 后撤]
   <br/>
   type = ChangeState
   <br/>
   value = 105
   <br/>
   Triggerall = Var(59) &gt; 0
   <br/>
   Triggerall = Roundstate = 2
   <br/>
   Triggerall = Statetype != A
   <br/>
   Triggerall = (Random &lt; Var(59)*200) || (Var(59) &gt; 3)
   <br/>
   Triggerall = ctrl
   <br/>
   Trigger1 = EnemyNear,Movetype = A &amp;&amp; EnemyNear,Stateno &gt;= 200;对方攻击状态
   <br/>
   Trigger1 = facing != EnemyNear,facing;双方面对面
   <br/>
   Trigger1 = EnemyNear,hitdefattr = SC,AT;对手攻击带投技判定
   <br/>
   Trigger1 = P2bodydist X = [-20,100];一定距离内
   <br/>
  </p>
  <p>
   ==================================================
   <br/>
   <span class="STYLE2">
    8.4跳跃
   </span>
   <br/>
   ==================================================
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   跳跃同样是格斗游戏常见的移动方式。
   <br/>
   因为跳跃能令攻击方式多样化（上下择和落地投等）而且有着相当高的回报，在手操里有着很重要的地位。
   <br/>
   同时还可以躲避投技和远处飞行道具，并获得先机。
   <br/>
   但是先不说mugen当中空防并不能防御下段攻击和一大堆无敌升龙，通常来说人物在空中只能按照一定的轨迹移动，
   <br/>
   而且多数格斗游戏中人物在地面的性能比空中要好，跳跃也需要好好考虑位置和时机才能在AI战里面使用。
   <br/>
   <br/>
   默认的common1.cns中代码如下：
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; Jump Start
   <br/>
   [Statedef 40]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   anim = 40
   <br/>
   ctrl = 0
   <br/>
   sprpriority = 1
   <br/>
   facep2 = 1
   <br/>
   <br/>
   [State 40, 1]
   <br/>
   type = VarSet
   <br/>
   trigger1 = Time = 0
   <br/>
   sysvar(1) = 0
   <br/>
   <br/>
   [State 40, 2]
   <br/>
   type = VarSet
   <br/>
   trigger1 = command = "holdfwd"
   <br/>
   sysvar(1) = 1
   <br/>
   <br/>
   [State 40, 3]
   <br/>
   type = VarSet
   <br/>
   trigger1 = command = "holdback"
   <br/>
   sysvar(1) = -1
   <br/>
   <br/>
   [State 40, 4]
   <br/>
   type = VelSet
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   x = ifelse(sysvar(1)=0, const(velocity.jump.neu.x), ifelse(sysvar(1)=1, const(velocity.jump.fwd.x), const(velocity.jump.back.x)))
   <br/>
   y = const(velocity.jump.y)
   <br/>
   <br/>
   [State 40, 5]
   <br/>
   type = VelSet
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   trigger1 = prevstateno = 100 ;RUN_FWD
   <br/>
   trigger1 = sysvar(1) = 1
   <br/>
   x = const(velocity.runjump.fwd.x)
   <br/>
   <br/>
   [State 40, 6]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   value = 50
   <br/>
   ctrl = 1
   <br/>
   <br/>
   <br/>
   如代码所示，和行走类似，默认的跳跃分为前跳、后跳、原地跳和跑跳，用的是同一个状态号40。
   <br/>
   也是通过按键不同区分开不同的方向和速度。
   <br/>
   而在某些有大小跳的作品里面，跳跃的分类会更多。
   <br/>
   所以我们会采用和行走一样的办法来处理。
   <br/>
   <br/>
   实例如下：
   <br/>
   ;--------------------------------------------------
   <br/>
   ;Statedef 39后跳 41前跳 42原地跳
   <br/>
   <br/>
   [Statedef 39]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   anim = 40
   <br/>
   ctrl = 0
   <br/>
   sprpriority = 1
   <br/>
   <br/>
   [State 40, 1]
   <br/>
   type = VarSet
   <br/>
   trigger1 = 1
   <br/>
   sysvar(1) = -1
   <br/>
   <br/>
   [State 40, 4]
   <br/>
   type = VelSet
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   x = const(velocity.jump.back.x)
   <br/>
   y = const(velocity.jump.y)
   <br/>
   <br/>
   [State 40, 6]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   value = 50
   <br/>
   ctrl = 1
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   [Statedef 41]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   anim = 40
   <br/>
   ctrl = 0
   <br/>
   sprpriority = 1
   <br/>
   <br/>
   [State 40, 1]
   <br/>
   type = VarSet
   <br/>
   trigger1 = 1
   <br/>
   sysvar(1) = 1
   <br/>
   <br/>
   [State 40, 4]
   <br/>
   type = VelSet
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   x = const(velocity.jump.fwd.x)
   <br/>
   y = const(velocity.jump.y)
   <br/>
   <br/>
   [State 40, 5]
   <br/>
   type = VelSet
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   trigger1 = prevstateno = 100 ;RUN_FWD
   <br/>
   trigger1 = sysvar(1) = 1
   <br/>
   x = const(velocity.runjump.fwd.x)
   <br/>
   <br/>
   [State 40, 6]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   value = 50
   <br/>
   ctrl = 1
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   [Statedef 42]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   anim = 40
   <br/>
   ctrl = 0
   <br/>
   sprpriority = 1
   <br/>
   <br/>
   [State 40, 1]
   <br/>
   type = VarSet
   <br/>
   trigger1 = 1
   <br/>
   sysvar(1) = 0
   <br/>
   <br/>
   [State 40, 4]
   <br/>
   type = VelSet
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   x = const(velocity.jump.neu.x)
   <br/>
   y = const(velocity.jump.y)
   <br/>
   <br/>
   [State 40, 6]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   value = 50
   <br/>
   ctrl = 1
   <br/>
  </p>
  <p>
   ====================================================
   <br/>
   <span class="STYLE2">
    8.5受身
   </span>
   <br/>
   ====================================================
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   受身是指受击身体恢复，通常是空中或者低空受击硬直后，或者倒地时可以更快的恢复成为可控状态。
   <br/>
   更快的恢复可控状态可以用于躲避对方的伪连（指中途可被受身回避的连段），或者更容易作出反击。
   <br/>
   <br/>
   <br/>
   默认的common1.cns中代码如下（此处因为WinMugen版本写的比较简单容易理解，我用WinMugen版本的代码进行讲解）：
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; HITA_FALL (knocked up, falling)
   <br/>
   [Statedef 5050]
   <br/>
   type    = A
   <br/>
   movetype= H
   <br/>
   physics = N
   <br/>
   <br/>
   ...
   <br/>
   <br/>
   [State 5050, 4] ;Recover near ground
   <br/>
   type = ChangeState
   <br/>
   triggerall = Vel Y &gt; 0
   <br/>
   triggerall = Pos Y &gt;= -20
   <br/>
   triggerall = alive
   <br/>
   triggerall = CanRecover
   <br/>
   trigger1 = Command = "recovery"
   <br/>
   value = 5200 ;HITFALL_RECOVER
   <br/>
   <br/>
   [State 5050, 5]; Recover in mid air
   <br/>
   type = ChangeState
   <br/>
   triggerall = Vel Y &gt; -1
   <br/>
   triggerall = alive
   <br/>
   triggerall = CanRecover
   <br/>
   trigger1 = Command = "recovery"
   <br/>
   value = 5210 ;HITFALL_AIRRECOVER
   <br/>
   <br/>
   ...
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   ; HIT_FALLRECOVER (still falling)
   <br/>
   [Statedef 5200]
   <br/>
   type    = A
   <br/>
   movetype= H
   <br/>
   physics = N
   <br/>
   <br/>
   [State 5200, 1] ;Change anim if done with transition
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = Anim = 5035
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   value = 5050
   <br/>
   <br/>
   [State 5200, 2]
   <br/>
   type = VelAdd
   <br/>
   trigger1 = 1
   <br/>
   y = GetHitVar(yaccel)
   <br/>
   <br/>
   [State 5200, 3]
   <br/>
   type = SelfState
   <br/>
   trigger1 = Vel Y &gt; 0
   <br/>
   trigger1 = Pos Y &gt;= 10
   <br/>
   value = 5201
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; HIT_FALLRECOVER (on the ground)
   <br/>
   [Statedef 5201]
   <br/>
   type    = A
   <br/>
   movetype= H
   <br/>
   physics = A
   <br/>
   anim = 5200
   <br/>
   <br/>
   [State 5201, 1] ;Turn if not facing opponent
   <br/>
   type = Turn
   <br/>
   trigger1 = Time = 0
   <br/>
   trigger1 = p2dist X &lt; -5
   <br/>
   <br/>
   [State 5201, 2]
   <br/>
   type = VelSet
   <br/>
   trigger1 = Time = 0
   <br/>
   x = -.15
   <br/>
   y = -3.5
   <br/>
   <br/>
   [State 5201, 3]
   <br/>
   type = PosSet
   <br/>
   trigger1 = Time = 0
   <br/>
   y = 0
   <br/>
   <br/>
   [State 5201, 4]
   <br/>
   type = NotHitBy
   <br/>
   trigger1 = 1
   <br/>
   value = SCA
   <br/>
   time = 1
   <br/>
   <br/>
   [State 5201, 5] ;Blink white
   <br/>
   type = PalFX
   <br/>
   trigger1 = Time = 0
   <br/>
   time = 3
   <br/>
   add = 128,128,128 ;256,256,256
   <br/>
   <br/>
   [State 5201, 6]
   <br/>
   type = GameMakeAnim
   <br/>
   trigger1 = Time = 1
   <br/>
   value = 60
   <br/>
   pos = 0, 0
   <br/>
   under = 1
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; HIT_AIRFALLRECOVER
   <br/>
   [Statedef 5210]
   <br/>
   type    = A
   <br/>
   movetype= I
   <br/>
   physics = N
   <br/>
   anim = 5210
   <br/>
   ctrl = 0
   <br/>
   <br/>
   [State 5210, 1] ;Blink white
   <br/>
   type = PalFX
   <br/>
   trigger1 = Time = 0
   <br/>
   time = 3
   <br/>
   add = 128,128,128 ;256,256,256
   <br/>
   <br/>
   [State 5210, 1]
   <br/>
   type = PosFreeze
   <br/>
   trigger1 = Time = 0
   <br/>
   value = 4
   <br/>
   <br/>
   [State 5210, 2] ;Turn if not facing opponent
   <br/>
   type = Turn
   <br/>
   trigger1 = Time = 0
   <br/>
   trigger1 = p2dist X &lt; -20
   <br/>
   <br/>
   [State 5210, 1]
   <br/>
   type = VelMul
   <br/>
   trigger1 = Time = 4
   <br/>
   x = .8
   <br/>
   y = .8
   <br/>
   <br/>
   [State 5210, 1]
   <br/>
   type = VelAdd
   <br/>
   trigger1 = Time = 4
   <br/>
   y = -4.5
   <br/>
   <br/>
   [State 5210, 1]
   <br/>
   type = VelMul
   <br/>
   trigger1 = Time = 4
   <br/>
   trigger1 = Vel Y &gt; 0
   <br/>
   y = .5
   <br/>
   <br/>
   [State 5210, 1]
   <br/>
   type = VelAdd
   <br/>
   trigger1 = Time = 4
   <br/>
   trigger1 = Vel Y &gt; -3
   <br/>
   y = -2
   <br/>
   <br/>
   [State 5210, 1]
   <br/>
   type = VelAdd
   <br/>
   trigger1 = Time = 4
   <br/>
   trigger1 = Vel Y &gt; -2
   <br/>
   y = -1
   <br/>
   <br/>
   [State 5210, 2] ;Go up
   <br/>
   type = VelAdd
   <br/>
   trigger1 = Time = 4
   <br/>
   trigger1 = Command = "holdup"
   <br/>
   y = -2
   <br/>
   <br/>
   [State 5210, 2] ;Go down
   <br/>
   type = VelAdd
   <br/>
   trigger1 = Time = 4
   <br/>
   trigger1 = Command = "holddown"
   <br/>
   y = 1.5
   <br/>
   <br/>
   [State 5210, 2] ;Go fwd
   <br/>
   type = VelMul
   <br/>
   trigger1 = Time = 4
   <br/>
   trigger1 = Command = "holdfwd"
   <br/>
   x = 1
   <br/>
   <br/>
   [State 5210, 2] ;Go back
   <br/>
   type = VelAdd
   <br/>
   trigger1 = Time = 4
   <br/>
   trigger1 = Command = "holdback"
   <br/>
   x = -1
   <br/>
   <br/>
   [State 5210, 3]
   <br/>
   type = NotHitBy
   <br/>
   trigger1 = Time = 0
   <br/>
   value = SCA
   <br/>
   time = 15
   <br/>
   <br/>
   [State 5210, 4]
   <br/>
   type = CtrlSet
   <br/>
   trigger1 = Time = 20
   <br/>
   value = 1
   <br/>
   <br/>
   [State 5210, 5]
   <br/>
   type = VelAdd;Gravity
   <br/>
   trigger1 = Time &gt;= 4
   <br/>
   y = .35
   <br/>
   <br/>
   [State 5210, 5] ;Land on ground
   <br/>
   type = ChangeState
   <br/>
   trigger1 = Vel Y &gt; 0
   <br/>
   trigger1 = Pos Y &gt;= 0
   <br/>
   value = 52 ;JUMP_LAND
   <br/>
   ctrl = 1
   <br/>
   <br/>
   <br/>
   如代码所示，Mugen当中默认有两种受身，分别是高空受身和低空受身，分别是状态5210和5200。
   <br/>
   其发动条件是在掉落状态5050当中处于可恢复状态时，速度和高度符合条件即可。
   <br/>
   高空受身5210是受身后20f恢复可控，而低空受身5200是进入预备状态到达低空高度转变为状态5201。
   <br/>
   值得一提的是，高空受身有15f的无敌，而低空受身在到达低空高度直到落地前的状态5201有全程无敌。
   <br/>
   如果可以在对方伪连时合理利用高空受身这15f的无敌和低空受身状态5201的全程无敌躲开对方的攻击判定，
   <br/>
   甚至之后在对方攻击硬直中反击命中对方的话，可以说是相当大的收益。
   <br/>
   然而受身其实也是有一定的风险的。高空受身在15f无敌以后有5f的硬直，而低空受身不可控，不可切换成防御状态，
   <br/>
   落地也有硬直，乱受身的话很容易被写了受身狩（也就是抓受身）抓住机会。
   <br/>
   另外有些AI也会用低硬直的招式骗对方手受身，一旦对方上当形成受身狩就是一套额外的连段。
   <br/>
   因为我们暂时还没有学出招记录等技术，没法特别精确地用受身躲避对方伪连，
   <br/>
   所以要注意受身的几率不要太高，以免被受身狩循环致死。
   <br/>
   <br/>
   <br/>
   实例如下：
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; HITA_FALL (knocked up, falling)
   <br/>
   [Statedef 5050]
   <br/>
   type    = A
   <br/>
   movetype= H
   <br/>
   physics = N
   <br/>
   <br/>
   ...
   <br/>
   <br/>
   [State 5050, 4] ;Recover near ground
   <br/>
   type = ChangeState
   <br/>
   triggerall = Vel Y &gt; 0
   <br/>
   triggerall = Pos Y &gt;= -20
   <br/>
   triggerall = alive
   <br/>
   triggerall = CanRecover
   <br/>
   trigger1 = Var(59) = 0;当手操时由手操命令控制
   <br/>
   trigger1 = Command = "recovery"
   <br/>
   trigger2 = Var(59) &gt; 0
   <br/>
   trigger2 = EnemyNear,Movetype = H || EnemyNear,Statetype = L;对方倒地或者受击
   <br/>
   value = 5200 ;HITFALL_RECOVER
   <br/>
   <br/>
   [State 5050, 5]; Recover in mid air
   <br/>
   type = ChangeState
   <br/>
   triggerall = Vel Y &gt; -1
   <br/>
   triggerall = alive
   <br/>
   triggerall = CanRecover
   <br/>
   trigger1 = Var(59) = 0;当手操时由手操命令控制
   <br/>
   trigger1 = Command = "recovery"
   <br/>
   trigger2 = Var(59) &gt; 0
   <br/>
   trigger2 = EnemyNear,Movetype = H || EnemyNear,Statetype = L
   <br/>
   Trigger3 = Var(59) &gt; 0
   <br/>
   Trigger3 = EnemyNear,Movetype = A &amp;&amp; EnemyNear,Stateno &gt;= 200;对方攻击状态
   <br/>
   Trigger3 = EnemyNear,AnimTime &lt;= -Random/40+5;对方有一定硬直时间
   <br/>
   Trigger3 = Random &lt; 100;低几率触发
   <br/>
   value = 5210 ;HITFALL_AIRRECOVER
   <br/>
   <br/>
   ...
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; HIT_AIRFALLRECOVER
   <br/>
   [Statedef 5210]
   <br/>
   type    = A
   <br/>
   movetype= I
   <br/>
   physics = N
   <br/>
   anim = 5210
   <br/>
   ctrl = 0
   <br/>
   <br/>
   ...
   <br/>
   ;具体方向控制看喜好
   <br/>
   <br/>
   [State 5210, 2] ;Go up
   <br/>
   type = VelAdd
   <br/>
   triggerall = Time = 4
   <br/>
   trigger1 = Var(59) = 0
   <br/>
   trigger1 = Command = "holdup"
   <br/>
   y = -2
   <br/>
   <br/>
   [State 5210, 2] ;Go down
   <br/>
   type = VelAdd
   <br/>
   triggerall = Time = 4
   <br/>
   trigger1 = Var(59) = 0
   <br/>
   trigger1 = Command = "holddown"
   <br/>
   trigger2 = Var(59) &gt; 0
   <br/>
   y = 1.5
   <br/>
   <br/>
   [State 5210, 2] ;Go fwd
   <br/>
   type = VelMul
   <br/>
   triggerall = Time = 4
   <br/>
   trigger1 = Var(59) = 0
   <br/>
   trigger1 = Command = "holdfwd"
   <br/>
   trigger2 = Var(59) &gt; 0
   <br/>
   x = 1
   <br/>
   <br/>
   [State 5210, 2] ;Go back
   <br/>
   type = VelAdd
   <br/>
   triggerall = Time = 4
   <br/>
   trigger1 = Var(59) = 0
   <br/>
   trigger1 = Command = "holdback"
   <br/>
   x = -1
   <br/>
  </p>
  <p>
   ==================================================
   <br/>
   <span class="STYLE2">
    8.6防御
   </span>
   <br/>
   ==================================================
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   格斗有攻就有守，防御不必多说是格斗游戏里面很重要的一环。
   <br/>
   防御对于攻击来说算相对简单，因为无论你怎么攻击，防御就三种：站防、蹲防、空防（有些游戏甚至没有空防）。
   <br/>
   除了投技不可防御、破防技等特殊情况，攻击判定（打击技和飞行道具）有分为上中下三段，可以被对应的防御防住。
   <br/>
   （PS：格斗游戏中，上段站、蹲防均可，中段不可蹲防，下段不可站防。但是Mugen当中，上段（guardflag = H）不可蹲防，
   <br/>
   中段（guardflag = M = HL）站、蹲防均可，下段（guardflag = L）不可站防，另外guardflag = A决定是否能空防。
   <br/>
   在本教程里统一用格斗游戏的说法，即中段不可蹲防，下段不可站防）
   <br/>
   <br/>
   <br/>
   默认的common1.cns中代码如下：
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; GUARD (start)
   <br/>
   [Statedef 120]
   <br/>
   type = U    ;Leave state type unchanged
   <br/>
   physics = U ;Leave physics unchanged
   <br/>
   <br/>
   [State 120, 1]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = Time = 0
   <br/>
   value = 120 + (statetype = C) + (statetype = A)*2;这种写法用一段代码完成了三段代码的工作，值得学习
   <br/>
   <br/>
   [State 120, 2]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = Time = 0 &amp;&amp; statetype = S
   <br/>
   physics = S
   <br/>
   <br/>
   [State 120, 3]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = Time = 0 &amp;&amp; statetype = C
   <br/>
   physics = C
   <br/>
   <br/>
   [State 120, 4]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = Time = 0 &amp;&amp; statetype = A
   <br/>
   physics = A
   <br/>
   <br/>
   [State 120, Hi to Lo]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = S &amp;&amp; command = "holddown"
   <br/>
   statetype = C
   <br/>
   physics = C
   <br/>
   <br/>
   [State 120, Lo to Hi]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = C &amp;&amp; command != "holddown"
   <br/>
   statetype = S
   <br/>
   physics = S
   <br/>
   <br/>
   [State 120, 5]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   value = 130 + (statetype = C) + (statetype = A)*2
   <br/>
   <br/>
   [State 120, Stop Guarding]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = command != "holdback"
   <br/>
   trigger2 = !inguarddist
   <br/>
   value = 140
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; STAND GUARD (guarding)
   <br/>
   [Statedef 130]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   <br/>
   [State 130, 1]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = Anim != 130
   <br/>
   value = 130
   <br/>
   <br/>
   [State 130, Hi to Lo]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = command = "holddown"
   <br/>
   value = 131
   <br/>
   <br/>
   [State 130, Stop Guarding]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = command != "holdback"
   <br/>
   trigger2 = !inguarddist
   <br/>
   value = 140
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; CROUCH GUARD (guarding)
   <br/>
   [Statedef 131]
   <br/>
   type    = C
   <br/>
   physics = C
   <br/>
   <br/>
   [State 131, 1]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = Anim != 131
   <br/>
   value = 131
   <br/>
   <br/>
   [State 131, Lo to Hi]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = command != "holddown"
   <br/>
   value = 130
   <br/>
   <br/>
   [State 131, Stop Guarding]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = command != "holdback"
   <br/>
   trigger2 = !inguarddist
   <br/>
   value = 140
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; AIR GUARD (guarding)
   <br/>
   [Statedef 132]
   <br/>
   type    = A
   <br/>
   physics = N
   <br/>
   <br/>
   [State 132, 1]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = Anim != 132
   <br/>
   value = 132
   <br/>
   <br/>
   [State 132, 2]
   <br/>
   type = VelAdd
   <br/>
   trigger1 = 1
   <br/>
   y = Const(movement.yaccel)
   <br/>
   <br/>
   [State 132, 3]
   <br/>
   type = VarSet
   <br/>
   trigger1 = 1
   <br/>
   sysvar(0) = (pos y &gt;= 0) &amp;&amp; (vel y &gt; 0)
   <br/>
   <br/>
   [State 132, 4]
   <br/>
   type = VelSet
   <br/>
   trigger1 = sysvar(0)
   <br/>
   y = 0
   <br/>
   <br/>
   [State 132, 5]
   <br/>
   type = PosSet
   <br/>
   trigger1 = sysvar(0)
   <br/>
   y = 0
   <br/>
   <br/>
   [State 132, 6]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = sysvar(0)
   <br/>
   trigger1 = command = "holdback"
   <br/>
   trigger1 = inguarddist
   <br/>
   value = 130
   <br/>
   <br/>
   [State 132, 7]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = sysvar(0)
   <br/>
   value = 52
   <br/>
   <br/>
   [State 132, Stop Guarding]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = command != "holdback"
   <br/>
   trigger2 = !inguarddist
   <br/>
   value = 140
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; GUARD (end)
   <br/>
   [Statedef 140]
   <br/>
   type = U    ;Leave state type unchanged
   <br/>
   physics = U ;Leave physics unchanged
   <br/>
   ctrl = 1
   <br/>
   <br/>
   [State 140, 1]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = Time = 0
   <br/>
   value = 140 + (statetype = C) + (statetype = A)*2
   <br/>
   <br/>
   [State 140, 2]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = Time = 0 &amp;&amp; statetype = S
   <br/>
   physics = S
   <br/>
   <br/>
   [State 140, 3]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = Time = 0 &amp;&amp; statetype = C
   <br/>
   physics = C
   <br/>
   <br/>
   [State 140, 4]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = Time = 0 &amp;&amp; statetype = A
   <br/>
   physics = A
   <br/>
   <br/>
   [State 140, Hi to Lo]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = S &amp;&amp; command = "holddown"
   <br/>
   statetype = C
   <br/>
   physics = C
   <br/>
   <br/>
   [State 140, Lo to Hi]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = C &amp;&amp; command != "holddown"
   <br/>
   statetype = S
   <br/>
   physics = S
   <br/>
   <br/>
   ;[State 140, 5] ;Implemented within engine
   <br/>
   ;type = ChangeState
   <br/>
   ;trigger1 = AnimTime = 0
   <br/>
   ;value = (statetype = C)*11 + (statetype = A)*51
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; SGUARDHIT (shaking)
   <br/>
   [Statedef 150]
   <br/>
   type    = S
   <br/>
   movetype= H
   <br/>
   physics = N
   <br/>
   velset = 0,0
   <br/>
   <br/>
   [State 150, 1]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = 1
   <br/>
   value = 150
   <br/>
   <br/>
   [State 150, 2]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = HitShakeOver
   <br/>
   value = 151 + 2*(command = "holddown")
   <br/>
   <br/>
   [State 150, Hi to Lo]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = S &amp;&amp; command = "holddown"
   <br/>
   statetype = C
   <br/>
   physics = C
   <br/>
   <br/>
   [State 150, Lo to Hi]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = C &amp;&amp; command != "holddown"
   <br/>
   statetype = S
   <br/>
   physics = S
   <br/>
   <br/>
   [State 150, 3]
   <br/>
   type = ForceFeedback
   <br/>
   trigger1 = time = 0
   <br/>
   waveform = square
   <br/>
   time = 3
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; SGUARDHIT2 (knocked back)
   <br/>
   [Statedef 151]
   <br/>
   type    = S
   <br/>
   movetype= H
   <br/>
   physics = S
   <br/>
   anim = 150
   <br/>
   <br/>
   [State 151, 1]
   <br/>
   type = HitVelSet
   <br/>
   trigger1 = Time = 0
   <br/>
   x = 1
   <br/>
   <br/>
   [State 151, 2]
   <br/>
   type = VelSet
   <br/>
   trigger1 = Time = GetHitVar(slidetime)
   <br/>
   trigger2 = HitOver
   <br/>
   x = 0
   <br/>
   <br/>
   [State 151, 3]
   <br/>
   type = CtrlSet
   <br/>
   trigger1 = Time = GetHitVar(ctrltime)
   <br/>
   value = 1
   <br/>
   <br/>
   [State 151, Hi to Lo]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = S &amp;&amp; command = "holddown"
   <br/>
   statetype = C
   <br/>
   physics = C
   <br/>
   <br/>
   [State 151, Lo to Hi]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = C &amp;&amp; command != "holddown"
   <br/>
   statetype = S
   <br/>
   physics = S
   <br/>
   <br/>
   [State 151, 4]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = HitOver
   <br/>
   value = 130
   <br/>
   ctrl = 1
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; CGUARDHIT (shaking)
   <br/>
   [Statedef 152]
   <br/>
   type    = C
   <br/>
   movetype= H
   <br/>
   physics = N
   <br/>
   velset = 0,0
   <br/>
   <br/>
   [State 152, 1]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = 1
   <br/>
   value = 151
   <br/>
   <br/>
   [State 152, 3]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = HitShakeOver
   <br/>
   value = 151 + 2*(command = "holddown")
   <br/>
   <br/>
   [State 152, Hi to Lo]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = S &amp;&amp; command = "holddown"
   <br/>
   statetype = C
   <br/>
   physics = C
   <br/>
   <br/>
   [State 152, Lo to Hi]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = C &amp;&amp; command != "holddown"
   <br/>
   statetype = S
   <br/>
   physics = S
   <br/>
   <br/>
   [State 152, 4]
   <br/>
   type = ForceFeedback
   <br/>
   trigger1 = time = 0
   <br/>
   waveform = square
   <br/>
   time = 4
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; CGUARDHIT2 (knocked back)
   <br/>
   [Statedef 153]
   <br/>
   type    = C
   <br/>
   movetype= H
   <br/>
   physics = C
   <br/>
   anim = 151
   <br/>
   <br/>
   [State 153, 1]
   <br/>
   type = HitVelSet
   <br/>
   trigger1 = Time = 0
   <br/>
   x = 1
   <br/>
   <br/>
   [State 153, 2]
   <br/>
   type = VelSet
   <br/>
   trigger1 = Time = GetHitVar(slidetime)
   <br/>
   trigger2 = HitOver
   <br/>
   x = 0
   <br/>
   <br/>
   [State 153, 3]
   <br/>
   type = CtrlSet
   <br/>
   trigger1 = Time = GetHitVar(ctrltime)
   <br/>
   value = 1
   <br/>
   <br/>
   [State 153, Hi to Lo]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = S &amp;&amp; command = "holddown"
   <br/>
   statetype = C
   <br/>
   physics = C
   <br/>
   <br/>
   [State 153, Lo to Hi]
   <br/>
   type = StateTypeSet
   <br/>
   trigger1 = statetype = C &amp;&amp; command != "holddown"
   <br/>
   statetype = S
   <br/>
   physics = S
   <br/>
   <br/>
   [State 153, 4]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = HitOver
   <br/>
   value = 131
   <br/>
   ctrl = 1
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; AGUARDHIT (shaking)
   <br/>
   [Statedef 154]
   <br/>
   type    = A
   <br/>
   movetype= H
   <br/>
   physics = N
   <br/>
   velset = 0,0
   <br/>
   <br/>
   [State 154, 1]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = 1
   <br/>
   value = 152
   <br/>
   <br/>
   [State 154, 2]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = HitShakeOver
   <br/>
   value = 155 ;AGUARDHIT2
   <br/>
   <br/>
   [State 154, 3]
   <br/>
   type = ForceFeedback
   <br/>
   trigger1 = time = 0
   <br/>
   waveform = square
   <br/>
   time = 4
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; AGUARDHIT2 (knocked away)
   <br/>
   [Statedef 155]
   <br/>
   type    = A
   <br/>
   movetype= H
   <br/>
   physics = N
   <br/>
   anim = 152
   <br/>
   <br/>
   [State 155, 1]
   <br/>
   type = HitVelSet
   <br/>
   trigger1 = Time = 0
   <br/>
   x = 1
   <br/>
   y = 1
   <br/>
   <br/>
   [State 155, 2]
   <br/>
   type = VelAdd
   <br/>
   trigger1 = 1
   <br/>
   y = Const(movement.yaccel)
   <br/>
   <br/>
   [State 155, 3]
   <br/>
   type = CtrlSet
   <br/>
   trigger1 = Time = GetHitVar(ctrltime)
   <br/>
   value = 1
   <br/>
   <br/>
   [State 155, 4]
   <br/>
   type = VarSet
   <br/>
   trigger1 = 1
   <br/>
   sysvar(0) = (pos y &gt;= 0) &amp;&amp; (vel y &gt; 0)
   <br/>
   <br/>
   [State 155, 5]
   <br/>
   type = VelSet
   <br/>
   trigger1 = sysvar(0)
   <br/>
   y = 0
   <br/>
   <br/>
   [State 155, 6]
   <br/>
   type = PosSet
   <br/>
   trigger1 = sysvar(0)
   <br/>
   y = 0
   <br/>
   <br/>
   [State 155, 6]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = sysvar(0)
   <br/>
   trigger1 = command = "holdback"
   <br/>
   trigger1 = inguarddist
   <br/>
   value = 130
   <br/>
   <br/>
   [State 155, 7]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = sysvar(0)
   <br/>
   value = 52
   <br/>
   <br/>
   <br/>
   防御状态默认占据了状态号[120,155]，中间根据防御不同阶段又细分了好几个状态。
   <br/>
   120是防御准备状态，也就是按下后方向键人物进入的动作，只用于转变为防御未受击状态；
   <br/>
   [130,132]是防御未受击状态，也就是做好了防御动作但是尚未被攻击的阶段，[130,132]分别对应站、蹲、空；
   <br/>
   140是防御结束状态，也就是防御准备状态、未受击状态或者受击状态结束时松开后方向键进入的状态，只用于离开防御状态；
   <br/>
   [150,155]是防御受击状态，防御准备状态或防御未受击状态受到攻击时进入的状态，[150,151]、[152,153]、[154,155]分别对应: 站、蹲、空，偶数为受击震动，奇数为受击滑动。在受击硬直后若还按着后方向键进入防御未受击状态，否则进入防御结束状态。
   <br/>
   <br/>
   防御状态的切换是已经写好了的，我们需要管的地方只有手操指令的切换。
   <br/>
   而这些切换无非控制的其实是站/蹲防的切换（空防你只有防与不放不用想太多）和停止防御状态两种。
   <br/>
   通常来说，站姿攻击多为上段和中段，蹲姿攻击多为上段和下段，空中攻击多为上段和中段。
   <br/>
   所以在地面上对站姿攻击和空中攻击我们用站防应对，对蹲姿攻击我们用蹲防应对，对方停止攻击的时候我们停止防御就行了。
   <br/>
   <br/>
   <br/>
   实例如下：
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; GUARD (start)
   <br/>
   [Statedef 120]
   <br/>
   type = U    ;Leave state type unchanged
   <br/>
   physics = U ;Leave physics unchanged
   <br/>
   <br/>
   ...
   <br/>
   <br/>
   [State 120, Hi to Lo]
   <br/>
   type = StateTypeSet
   <br/>
   triggerall = statetype = S;当我方是站姿
   <br/>
   trigger1 = !Var(59) &amp;&amp; command = "holddown"
   <br/>
   trigger2 = Var(59) &amp;&amp; EnemyNear,Statetype = C;而对方是蹲姿的时候
   <br/>
   statetype = C;变为蹲姿
   <br/>
   physics = C
   <br/>
   <br/>
   [State 120, Lo to Hi]
   <br/>
   type = StateTypeSet
   <br/>
   triggerall = statetype = C;当我方是蹲姿
   <br/>
   trigger1 = !Var(59) &amp;&amp; command != "holddown"
   <br/>
   trigger2 = Var(59) &amp;&amp; EnemyNear,Statetype = S;而对方是站姿的时候
   <br/>
   statetype = S;变为站姿
   <br/>
   physics = S
   <br/>
   <br/>
   [State 120, 5]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = AnimTime = 0
   <br/>
   value = 130 + (statetype = C) + (statetype = A)*2
   <br/>
   <br/>
   [State 120, Stop Guarding]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = !Var(59) &amp;&amp; command != "holdback"
   <br/>
   trigger2 = !inguarddist
   <br/>
   value = 140
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; STAND GUARD (guarding)
   <br/>
   [Statedef 130]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   <br/>
   [State 130, 1]
   <br/>
   type = ChangeAnim
   <br/>
   trigger1 = Anim != 130
   <br/>
   value = 130
   <br/>
   <br/>
   [State 130, Hi to Lo]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = !Var(59) &amp;&amp; command = "holddown"
   <br/>
   trigger2 = Var(59) &amp;&amp; EnemyNear,Statetype = C
   <br/>
   value = 131
   <br/>
   <br/>
   [State 130, Stop Guarding]
   <br/>
   type = ChangeState
   <br/>
   trigger1 = !Var(59) &amp;&amp; command != "holdback"
   <br/>
   trigger2 = !inguarddist
   <br/>
   value = 140
   <br/>
   <br/>
   <br/>
   ;因为下面的站/蹲姿切换都是类似的代码，以上面的当做参考足矣，下略
   <br/>
   ......
   <br/>
   <br/>
   <br/>
   之后还有启动防御的Changestate：
   <br/>
   <br/>
   ;下面一段放到[Statedef -1]或[Statedef -3]下面
   <br/>
   ;--------------------------------------------------
   <br/>
   [State -1, 防御]
   <br/>
   type = ChangeState
   <br/>
   value = 120
   <br/>
   Triggerall = Var(59) &gt; 0
   <br/>
   Triggerall = Roundstate = 2
   <br/>
   Triggerall = Statetype != A
   <br/>
   Triggerall = ctrl
   <br/>
   Triggerall = !(EnemyNear(Var(54)),hitdefattr = sca,at);对方不是投技判定
   <br/>
   Trigger1 = Inguarddist ;在防御范围内
   <br/>
   <br/>
   <br/>
   完成这段的修改，你也限制了人物攻击的话，你的人物已经算是铁壁了。
   <br/>
   什么？你说铁壁这么简单？没错，只要不主动攻击卖硬直，铁壁就是这么简单。
   <br/>
  </p>
  <p>
   ====================================================
   <br/>
   <span class="STYLE2">
    8.7限制隐性手操指令切换状态
   </span>
   <br/>
   ====================================================
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   到这里我们已经把带有command的Sctrl修改完了，但是这章内容尚未完结。
   <br/>
   还记得笔者在第5章提及的内容吗：除了带有command的Sctrl以外，Mugen里面还存在内置的隐性的手操指令切换状态，
   <br/>
   例如下蹲（Stateno 10）、行走（Stateno 20）和跳跃（Stateno 40）等。
   <br/>
   我们虽然修改了这几个动作里面的带command的内容，但是我们还没有对它们的触发进行限制。
   <br/>
   只要人物处于可控状态，只要内置的隐性的用手操指令刚好被触发，这几个动作依然会不受控制的动起来。
   <br/>
   所以除了上面的内容，我们还要限制隐性手操指令切换状态。
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   因为人物要处于可控状态才会切换状态为下蹲、行走和跳跃等状态，所以首先我们可以把一些可控的状态改成不可控。
   <br/>
   在Statedef开始的地方，如果没有标注说是否可控，将会继承上一个状态的可控与否。
   <br/>
   例如从可控的站姿切换到行走，行走并没有标注是否可控，行走也将变成可控。
   <br/>
   分析之前的代码可知，Mugen默认的行走和跑都可以从可控状态进入，所以这两个状态都可能会被隐性的手操指令切换状态。
   <br/>
   于是我们可以进行修改，实例如下：
   <br/>
   <br/>
   <br/>
   ;因为我们已经采用了新的行走状态State 19/21，所以我们可以不用修改State 20
   <br/>
   ;--------------------------------------------------
   <br/>
   ; Walk B 向后走
   <br/>
   [Statedef 19]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   sprpriority = 0
   <br/>
   ctrl = 0;不可控
   <br/>
   <br/>
   ...
   <br/>
   <br/>
   ;--------------------------------------------------
   <br/>
   ; Walk F 向前走
   <br/>
   [Statedef 21]
   <br/>
   type    = S
   <br/>
   physics = S
   <br/>
   sprpriority = 0
   <br/>
   ctrl = 0;不可控
   <br/>
   <br/>
   <br/>
   ;而State 100，我们可以像行走那样添加新的状态，设置为不可控，或者是像下面这么修改
   <br/>
   ;--------------------------------------------------
   <br/>
   ; Run forward
   <br/>
   [Statedef 100]
   <br/>
   <br/>
   ...
   <br/>
   <br/>
   [State 100, AI Ctrlset];添加不可控设置
   <br/>
   type = Ctrlset
   <br/>
   trigger1 = Var(59) &gt; 0;当AI开关打开的时候
   <br/>
   value = 0;不可控
   <br/>
   <br/>
   <br/>
   通过这样的修改，在行走和跑步的时候就不会被手操指令影响了，但缺点就是不可控状态可能会混淆对方AI，我们在写AI的时候也要注意这种写法可能对我们带来的不良影响。
   <br/>
   另外，由于原来可控的状态现在变成了不可控，所以其他Sctrl里原来triggerX = ctrl的条件不作相应调整的话人物就变得不会动了，因此我们还需要调整这些trigger，令他们可以在这些原来是可控的状态里跟原来一样切换状态。例如：
   <br/>
   <br/>
   ;Stand Light Punch
   <br/>
   [State -1, Stand Light Punch]
   <br/>
   type = ChangeState
   <br/>
   value = 200
   <br/>
   trigger1 = Var(59) &gt; 0
   <br/>
   trigger1 = statetype = S
   <br/>
   trigger1 = ctrl
   <br/>
   <br/>
   改为
   <br/>
   <br/>
   ;Stand Light Punch
   <br/>
   [State -1, Stand Light Punch]
   <br/>
   type = ChangeState
   <br/>
   value = 200
   <br/>
   trigger1 = Var(59) &gt; 0
   <br/>
   trigger1 = statetype = S
   <br/>
   trigger1 = ctrl || (Stateno = [19,21]) || Stateno = 100;这样就算不可控，行走和跑时都可以切换状态了
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   然而修改了行走和跑步依然还是不够的，站姿等可控的情况下依然会乱动。
   <br/>
   所以为了对应大多数的可控情况，我们还需要一段泛用的限制代码：
   <br/>
   <br/>
   ;下面一段放到[Statedef -1]或[Statedef -3]下面
   <br/>
   ;--------------------------------------------------
   <br/>
   [State -1, 地面动作限制]
   <br/>
   type = ChangeState
   <br/>
   value = 0;强行拉回站姿
   <br/>
   Triggerall = Var(59) &gt; 0
   <br/>
   Triggerall = Statetype != A
   <br/>
   Triggerall = Roundstate = 2
   <br/>
   Trigger1 = Stateno = 10;下蹲
   <br/>
   Trigger2 = Stateno = 20;行走
   <br/>
   Trigger3 = Stateno = 40;跳
   <br/>
   ctrl = 1
   <br/>
   <br/>
   虽然有部分魔改的成分（笑），但是这种是比较常用而且实在的限制乱动的写法了。
   <br/>
   <br/>
   --------------------------------------------------
   <br/>
   至此，公用状态算是基本完成了。
   <br/>
   随着以后不同目的的章节的探讨，我们还会继续给这些公用状态添加一些trigger，令它们在适当的时候触发。
   <br/>
   不过那是之后的事了，本章只讲这么多。
   <br/>
  </p>
  <p>
   ====================================================
   <br/>
   <span class="STYLE2">
    课后作业：
   </span>
   <br/>
   <br/>
   1.
   <br/>
   格斗游戏中，什么段攻击可以击破蹲防？什么段攻击可以击破站防？
   <br/>
   <br/>
   2.
   <br/>
   为什么说章节8.7的这段代码有部分魔改的成分？
   <br/>
   <br/>
   [State -1, 地面动作限制]
   <br/>
   type = ChangeState
   <br/>
   value = 0
   <br/>
   Triggerall = Var(59) &gt; 0
   <br/>
   Triggerall = Statetype != A
   <br/>
   Triggerall = Roundstate = 2
   <br/>
   Trigger1 = Stateno = 10
   <br/>
   Trigger2 = Stateno = 20
   <br/>
   Trigger3 = Stateno = 40
   <br/>
   ctrl = 1
   <br/>
  </p>
  <p>
  </p>
 </body>
</html>
